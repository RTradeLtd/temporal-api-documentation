# IPFS HTTP API Proxy


The IPFS HTTP API reverse proxy uses a customized proxy solution developed in-house specificaly for the IPFS HTTP API. It is compatible with all IPFS HTTP API libraries, as long as they provide the ability for you to insert the JWT generated by Temporal into the authentication header, as it uses the same authentication methods that Temporal's HTTP API uses.

Before using this API please read in detail how it works.

Endpoint URLs:

* Production `https://api.ipfs.temporal.cloud`
* Development `https://dev.api.ipfs.temporal.cloud`

For a list of IPFS HTTP API calls that are white-listed when using this endpoint, please see the following [gist](https://gist.github.com/postables/55be1cf00e8ffafff6e663c198bf6482) which will be updated whenever calls are added/removed.

Usage of this API is tied into the billing system of Temporal, so you will need a valid Temporal account to use this API. Any API calls that involve storing data, such as `object/new`, `object/set-data`, `dag/put`, etc.. will trigger pinning of the data for **1 month**. 

If your account is a free account, we will make sure that the size of the data won't breach the 3GB free storage amount. If it does, the API call will be reverted and you'll receive an error message. If your account is a paid account, we will make sure that your account has enough credits to cover storing the data for 1 month. If your account doesn't have enough credits, the API call will be reverted and you'll receive an error message. If you want to store the data for longer than one month, you'll need to use Temporal's HTTP API, and invoke the `extend pin` API call to extend the pin duration. 

Any calls that involve "retrieving data" aren't rate limited and you're free to use them as you please. To increase performance, data retrieval calls go through a caching system. If you want to skip the caching system receive uncached responses, set the `Cache-Control` header to `"no-store"`.

## Example

```go
package main

import (
    "fmt"
    "log"
    "os"

    // fork of ipfs/go-ipfs-api which allows using jwt for authentication
    ipfs "github.com/RTradeLtd/go-ipfs-api"
    // helper library to login and authenticate with Temporal's HTTP API
    thc "github.com/RTradeLtd/thc"
)

const (
    temporalReverseProxy = "https://api.ipfs.temporal.cloud"
    exampleCID           = "QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv"
)

func main() {
    temporalUser := os.Getenv("TEMPORAL_USER")
    if temporalUser == "" {
        log.Fatal("TEMPORAL_USER env var must not be empty")
    }
    temporalPass := os.Getenv("TEMPORAL_PASS")
    if temporalPass == "" {
        log.Fatal("TEMPORAL_PASS env var must not be empty")
    }
    // initialize a V2 Temporal API client
    tClient := thc.NewV2(temporalUser, temporalPass, thc.DevURL)
    // login with Temporal to generate the JWT
    if err := tClient.Login(); err != nil {
        fmt.Println("failed to login with error", err)
        log.Fatal(err)
    }
    // get the JWT
    jwt, err := tClient.GetJWT()
    if err != nil {
        log.Fatal(err)
    }
    // create a shell with the reverse proxy endpoint
    // the difference between direct shell and the typical
    // NewShell function, is that NewDirectShell won't fail
    // if you provide an invalid multiaddr, this is different
    // from js-ipfs-http-client which doesn't do this
    shell := ipfs.NewDirectShell(temporalReverseProxy)
    // WithAuthorization allows providing the JWT as a header in the http connection
    // It returns a type `Shell` which you then call `Pin` on
    if err := shell.WithAuthorization(jwt).Pin(exampleCID); err != nil {
        fmt.Println("failed to pin with error", err)
        log.Fatal(err)
    }
    fmt.Println("successfully pinned", exampleCID)
}
```

```python
Python code here.
```

```shell
curl -X POST \
  'https://api.ipfs.temporal.cloud/api/v0/pin/add?arg=QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv&stream-channels=true' \
  -H 'Authorization: Bearer <your-jwt-here>' \
  -H 'cache-control: no-cache'
```

```http
POST /api/v0/pin/add?arg=QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv&stream-channels=true HTTP/1.1
Host: api.ipfs.temporal.cloud
User-Agent: curl/7.58.0
Accept: */*
Authorization: Bearer <jwt-omitted>
cache-control: no-cache
```

```javascript
var ipfsClient = require('ipfs-http-client')

// example cid to pin
var exampleCID = 'QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv'
// TEMPORAL_JWT is an environment variable used to provide the jwt needed to authenticate with temoral
// optionally, you could import https://github.com/clemlak/temporal-js and use the login function
// to return the jwt
var jwt = process.env.TEMPORAL_JWT

// specify how we will connect the ipfs client
var ipfs = ipfsClient({
    // the hostname (or ip address) of the endpoint providing the ipfs api
    host: 'api.ipfs.temporal.cloud',
    // the port to connect on
    port: '443',
    'api-path': '/api/v0/',
    // the protocol, https for security
    protocol: 'https',
    // provide the jwt within an authorization header
    headers: {
        authorization: 'Bearer ' + jwt
    }
})

// use the js-ipfs-http-client library to pin a particular CID
// this will be procesed like any other IPFS API, however
// it will be backed up by the infrastructure under Temporal.
ipfs.pin.add(exampleCID, function (err, response) {
    if (err) {
        console.error(err, err.stack)
        throw  err
    }
    console.log(response)
})
```

> Example Response (200)

```
{
    "Pins": [
        "QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv"
    ]
}
```

This example demonstrates using the IPFS HTTP API endpoint to pin a file. Examples are given in javascript, golang, and using the curl command.